<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>üìä Bonus Code Predictions - CollectClock</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  
  <style>
    :root {
      /* Light mode color palette */
      --bg: #f8fafc;
      --text: #1e293b;
      --text-secondary: #64748b;
      --text-muted: #94a3b8;
      --primary: #0f172a;
      --primary-light: #334155;
      --accent: #3b82f6;
      --accent-light: #dbeafe;
      --success: #10b981;
      --success-light: #d1fae5;
      --danger: #ef4444;
      --danger-light: #fee2e2;
      --warning: #f59e0b;
      --warning-light: #fef3c7;
      --border: #e2e8f0;
      --border-light: #f1f5f9;
      --card-bg: #ffffff;
      --card-hover: #f8fafc;
      --shadow: rgba(15, 23, 42, 0.08);
      --shadow-hover: rgba(15, 23, 42, 0.12);
    }
    
    [data-theme="dark"] {
      /* Dark mode color palette */
      --bg: #0f172a;
      --text: #f1f5f9;
      --text-secondary: #94a3b8;
      --text-muted: #64748b;
      --primary: #f1f5f9;
      --primary-light: #cbd5e1;
      --accent: #60a5fa;
      --accent-light: #1e3a5f;
      --success: #34d399;
      --success-light: #064e3b;
      --danger: #f87171;
      --danger-light: #7f1d1d;
      --warning: #fbbf24;
      --warning-light: #78350f;
      --border: #1e293b;
      --border-light: #334155;
      --card-bg: #1e293b;
      --card-hover: #334155;
      --shadow: rgba(0, 0, 0, 0.3);
      --shadow-hover: rgba(0, 0, 0, 0.4);
    }
    
    * {
      box-sizing: border-box;
    }
    
    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto', sans-serif;
      background: var(--bg);
      color: var(--text);
      margin: 0;
      min-height: 100vh;
      line-height: 1.6;
      font-size: 14px;
      padding: 2rem 1rem;
    }
    
    .container { 
      max-width: 1200px; 
      margin: 0 auto;
    }
    
    h1 { 
      text-align: center; 
      font-size: 2.5rem; 
      font-weight: 700;
      color: var(--primary);
      margin: 1rem 0 2rem 0;
      letter-spacing: -0.025em;
    }

    h2 {
      font-size: 1.75rem;
      color: var(--primary);
      margin: 2rem 0 1rem 0;
      font-weight: 600;
    }

    h3 {
      font-size: 1.25rem;
      color: var(--primary);
      margin: 1.5rem 0 0.75rem 0;
      font-weight: 600;
    }
    
    .header-actions {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 2rem;
      gap: 1rem;
      flex-wrap: wrap;
    }
    
    .theme-toggle {
      padding: 0.75rem;
      background: var(--card-bg);
      color: var(--text);
      border: 2px solid var(--border);
      border-radius: 8px;
      font-size: 1.25rem;
      cursor: pointer;
      transition: all 0.2s ease;
      display: flex;
      align-items: center;
      justify-content: center;
      width: 46px;
      height: 46px;
    }
    
    .theme-toggle:hover {
      background: var(--card-hover);
      border-color: var(--accent);
    }

    .discord-btn {
      padding: 0.75rem 1.5rem;
      background: linear-gradient(135deg, #5865F2, #7289DA);
      color: white;
      border: none;
      border-radius: 8px;
      font-size: 0.9rem;
      font-weight: 600;
      cursor: pointer;
      transition: all 0.3s ease;
      display: flex;
      align-items: center;
      gap: 0.5rem;
      box-shadow: 0 2px 8px rgba(88, 101, 242, 0.3);
    }
    
    .discord-btn:hover {
      transform: translateY(-2px);
      box-shadow: 0 4px 12px rgba(88, 101, 242, 0.4);
      background: linear-gradient(135deg, #4752C4, #5865F2);
    }
    
    .discord-modal {
      display: none;
      position: fixed;
      z-index: 4000;
      left: 0;
      top: 0;
      width: 100vw;
      height: 100vh;
      background: rgba(0, 0, 0, 0.7);
      align-items: center;
      justify-content: center;
    }
    
    .discord-modal-content {
      background: var(--card-bg);
      padding: 2rem;
      border-radius: 16px;
      max-width: 500px;
      width: 90%;
      box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
      border: 2px solid var(--accent);
    }
    
    .discord-modal-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 1.5rem;
    }
    
    .discord-modal-header h2 {
      margin: 0;
      color: var(--primary);
      display: flex;
      align-items: center;
      gap: 0.5rem;
    }
    
    .modal-close {
      background: none;
      border: none;
      font-size: 1.5rem;
      cursor: pointer;
      color: var(--text-secondary);
      padding: 0;
      width: 32px;
      height: 32px;
      border-radius: 50%;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: all 0.2s ease;
    }
    
    .modal-close:hover {
      background: var(--border-light);
      color: var(--text);
    }
    
    .discord-input {
      width: 100%;
      padding: 0.75rem;
      border: 2px solid var(--border);
      border-radius: 8px;
      font-size: 1rem;
      background: var(--bg);
      color: var(--text);
      margin: 0.5rem 0;
      transition: border-color 0.2s ease;
    }
    
    .discord-input:focus {
      outline: none;
      border-color: var(--accent);
    }
    
    .discord-submit-btn {
      width: 100%;
      padding: 0.75rem;
      background: linear-gradient(135deg, #5865F2, #7289DA);
      color: white;
      border: none;
      border-radius: 8px;
      font-size: 1rem;
      font-weight: 600;
      cursor: pointer;
      margin-top: 1rem;
      transition: all 0.3s ease;
    }
    
    .discord-submit-btn:hover {
      transform: translateY(-2px);
      box-shadow: 0 4px 12px rgba(88, 101, 242, 0.4);
    }
    
    .discord-submit-btn:disabled {
      opacity: 0.5;
      cursor: not-allowed;
      transform: none;
    }

    .back-btn {
      padding: 0.75rem 1.5rem;
      background: var(--primary);
      color: white;
      border: none;
      border-radius: 8px;
      font-size: 0.875rem;
      font-weight: 500;
      cursor: pointer;
      transition: background-color 0.2s ease;
      text-decoration: none;
      display: inline-block;
    }
    
    .back-btn:hover {
      background: var(--primary-light);
    }
    
    .card {
      background: var(--card-bg);
      border: 1px solid var(--border);
      border-radius: 12px;
      padding: 1.5rem;
      margin-bottom: 1.5rem;
      box-shadow: 0 1px 3px var(--shadow);
      transition: all 0.2s ease;
    }
    
    .card:hover {
      box-shadow: 0 4px 6px var(--shadow-hover);
    }
    
    .prediction-card {
      background: linear-gradient(135deg, var(--accent-light), var(--card-bg));
      border: 2px solid var(--accent);
      padding: 2rem;
    }
    
    .stat-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
      gap: 1rem;
      margin: 1.5rem 0;
    }
    
    .stat-box {
      background: var(--border-light);
      padding: 1.25rem;
      border-radius: 8px;
      text-align: center;
    }
    
    .stat-value {
      font-size: 2rem;
      font-weight: 700;
      color: var(--accent);
      margin-bottom: 0.25rem;
    }
    
    .stat-label {
      font-size: 0.875rem;
      color: var(--text-secondary);
      text-transform: uppercase;
      letter-spacing: 0.05em;
    }
    
    .chart-container {
      margin: 2rem 0;
      padding: 1rem;
      background: var(--border-light);
      border-radius: 8px;
    }
    
    .bar-chart {
      display: flex;
      align-items: flex-end;
      justify-content: space-around;
      height: 200px;
      margin: 1rem 0;
      gap: 0.5rem;
    }
    
    .bar {
      flex: 1;
      background: var(--accent);
      border-radius: 4px 4px 0 0;
      position: relative;
      transition: all 0.3s ease;
      min-height: 5px;
    }
    
    .bar:hover {
      background: var(--primary);
      transform: translateY(-4px);
    }
    
    .bar-label {
      position: absolute;
      bottom: -25px;
      left: 50%;
      transform: translateX(-50%);
      font-size: 0.75rem;
      color: var(--text-secondary);
      white-space: nowrap;
    }
    
    .bar-value {
      position: absolute;
      top: -25px;
      left: 50%;
      transform: translateX(-50%);
      font-size: 0.75rem;
      font-weight: 600;
      color: var(--text);
    }
    
    .time-heatmap {
      display: grid;
      grid-template-columns: repeat(12, 1fr);
      gap: 0.5rem;
      margin: 1.5rem 0;
    }
    
    .heatmap-cell {
      aspect-ratio: 1;
      border-radius: 4px;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 0.75rem;
      font-weight: 600;
      color: var(--text);
      transition: transform 0.2s ease;
    }
    
    .heatmap-cell:hover {
      transform: scale(1.1);
    }
    
    .confidence-meter {
      width: 100%;
      height: 30px;
      background: var(--border-light);
      border-radius: 15px;
      overflow: hidden;
      position: relative;
      margin: 1rem 0;
    }
    
    .confidence-fill {
      height: 100%;
      background: linear-gradient(90deg, var(--danger), var(--warning), var(--success));
      transition: width 0.5s ease;
      display: flex;
      align-items: center;
      justify-content: flex-end;
      padding-right: 1rem;
      color: white;
      font-weight: 700;
      font-size: 0.875rem;
    }
    
    .prediction-list {
      list-style: none;
      padding: 0;
      margin: 1.5rem 0;
    }
    
    .prediction-item {
      background: var(--border-light);
      padding: 1rem 1.5rem;
      margin-bottom: 0.75rem;
      border-radius: 8px;
      border-left: 4px solid var(--accent);
      display: flex;
      justify-content: space-between;
      align-items: center;
      transition: all 0.2s ease;
    }
    
    .prediction-item:hover {
      background: var(--card-hover);
      transform: translateX(4px);
    }
    
    .prediction-date {
      font-weight: 600;
      color: var(--primary);
      font-size: 1rem;
    }
    
    .prediction-amount {
      background: var(--success);
      color: white;
      padding: 0.25rem 0.75rem;
      border-radius: 20px;
      font-weight: 600;
      font-size: 0.875rem;
    }
    
    .prediction-confidence {
      color: var(--text-secondary);
      font-size: 0.875rem;
    }
    
    .badge {
      display: inline-block;
      padding: 0.25rem 0.75rem;
      border-radius: 20px;
      font-size: 0.75rem;
      font-weight: 600;
      margin: 0.25rem;
    }
    
    .badge-high {
      background: var(--success-light);
      color: var(--success);
    }
    
    .badge-medium {
      background: var(--warning-light);
      color: var(--warning);
    }
    
    .badge-low {
      background: var(--danger-light);
      color: var(--danger);
    }
    
    .badge-holiday {
      background: linear-gradient(135deg, #ff6b6b, #ffd93d);
      color: #fff;
      font-weight: 700;
      padding: 0.5rem 1rem;
      font-size: 0.85rem;
      box-shadow: 0 2px 8px rgba(255, 107, 107, 0.3);
      animation: pulse 2s ease-in-out infinite;
    }
    
    @keyframes pulse {
      0%, 100% { transform: scale(1); }
      50% { transform: scale(1.02); }
    }
    
    .insight-box {
      background: var(--accent-light);
      border-left: 4px solid var(--accent);
      padding: 1rem 1.5rem;
      margin: 1rem 0;
      border-radius: 4px;
    }
    
    .insight-box strong {
      color: var(--accent);
    }
    
    .refresh-btn {
      margin-left: 0.5rem;
      padding: 0.4rem 1rem;
      background: var(--accent);
      color: white;
      border: none;
      border-radius: 20px;
      cursor: pointer;
      font-size: 0.85rem;
      font-weight: 600;
      transition: all 0.2s ease;
    }
    
    .refresh-btn:hover {
      background: var(--primary);
      transform: translateY(-1px);
      box-shadow: 0 2px 8px var(--shadow);
    }
    
    .refresh-btn:disabled {
      opacity: 0.6;
      cursor: not-allowed;
      transform: none;
    }
    
    .report-drop-btn {
      padding: 0.75rem 1.5rem;
      background: linear-gradient(135deg, var(--success), #059669);
      color: white;
      border: none;
      border-radius: 8px;
      font-size: 0.9rem;
      font-weight: 600;
      cursor: pointer;
      transition: all 0.3s ease;
      display: flex;
      align-items: center;
      gap: 0.5rem;
      box-shadow: 0 2px 8px rgba(16, 185, 129, 0.3);
      margin-top: 1rem;
    }
    
    .report-drop-btn:hover {
      transform: translateY(-2px);
      box-shadow: 0 4px 12px rgba(16, 185, 129, 0.4);
      background: linear-gradient(135deg, #059669, #047857);
    }
    
    .verification-modal {
      display: none;
      position: fixed;
      z-index: 4000;
      left: 0;
      top: 0;
      width: 100vw;
      height: 100vh;
      background: rgba(0, 0, 0, 0.7);
      align-items: center;
      justify-content: center;
      overflow-y: auto;
      padding: 1rem;
    }
    
    .verification-modal-content {
      background: var(--card-bg);
      padding: 2rem;
      border-radius: 16px;
      max-width: 600px;
      width: 100%;
      box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
      border: 2px solid var(--success);
      max-height: 90vh;
      overflow-y: auto;
    }
    
    .form-group {
      margin-bottom: 1.5rem;
    }
    
    .form-group label {
      display: block;
      margin-bottom: 0.5rem;
      font-weight: 600;
      color: var(--text);
    }
    
    .form-input {
      width: 100%;
      padding: 0.75rem;
      border: 2px solid var(--border);
      border-radius: 8px;
      font-size: 1rem;
      background: var(--bg);
      color: var(--text);
      transition: border-color 0.2s ease;
    }
    
    .form-input:focus {
      outline: none;
      border-color: var(--success);
    }
    
    .form-submit-btn {
      width: 100%;
      padding: 0.75rem;
      background: linear-gradient(135deg, var(--success), #059669);
      color: white;
      border: none;
      border-radius: 8px;
      font-size: 1rem;
      font-weight: 600;
      cursor: pointer;
      transition: all 0.3s ease;
    }
    
    .form-submit-btn:hover {
      transform: translateY(-2px);
      box-shadow: 0 4px 12px rgba(16, 185, 129, 0.4);
    }
    
    .form-submit-btn:disabled {
      opacity: 0.5;
      cursor: not-allowed;
      transform: none;
    }
    
    .accuracy-card {
      background: linear-gradient(135deg, var(--success-light), var(--card-bg));
      border: 2px solid var(--success);
    }
    
    .accuracy-stat {
      text-align: center;
      padding: 1rem;
    }
    
    .accuracy-value {
      font-size: 2.5rem;
      font-weight: 700;
      color: var(--success);
      margin-bottom: 0.25rem;
    }
    
    .accuracy-label {
      font-size: 0.875rem;
      color: var(--text-secondary);
      text-transform: uppercase;
      letter-spacing: 0.05em;
    }
    
    .trend-indicator {
      display: inline-flex;
      align-items: center;
      gap: 0.25rem;
      font-size: 1.25rem;
      margin-left: 0.5rem;
    }
    
    .trend-up {
      color: var(--success);
    }
    
    .trend-down {
      color: var(--danger);
    }
    
    .verification-list {
      list-style: none;
      padding: 0;
      margin: 1rem 0;
    }
    
    .verification-item {
      background: var(--border-light);
      padding: 1rem;
      margin-bottom: 0.75rem;
      border-radius: 8px;
      border-left: 4px solid var(--success);
    }
    
    .verification-item.inaccurate {
      border-left-color: var(--warning);
    }
    
    .verification-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 0.5rem;
    }
    
    .verification-details {
      font-size: 0.875rem;
      color: var(--text-secondary);
      line-height: 1.6;
    }
    
    .accuracy-badge {
      padding: 0.25rem 0.75rem;
      border-radius: 20px;
      font-size: 0.75rem;
      font-weight: 600;
    }
    
    .accuracy-excellent {
      background: var(--success-light);
      color: var(--success);
    }
    
    .accuracy-good {
      background: var(--accent-light);
      color: var(--accent);
    }
    
    .accuracy-fair {
      background: var(--warning-light);
      color: var(--warning);
    }
    
    .accuracy-poor {
      background: var(--danger-light);
      color: var(--danger);
    }
    
    @media (max-width: 768px) {
      h1 {
        font-size: 1.75rem;
      }
      
      .stat-grid {
        grid-template-columns: 1fr;
      }
      
      .bar-chart {
        height: 150px;
      }
      
      .time-heatmap {
        grid-template-columns: repeat(6, 1fr);
      }
      
      .prediction-item {
        flex-direction: column;
        align-items: flex-start;
        gap: 0.5rem;
      }
    }
  </style>
</head>
<body>
  <div class="container">
    <div class="header-actions">
      <a href="index.html" class="back-btn">‚Üê Back to CollectClock</a>
      <div style="display: flex; gap: 0.5rem; align-items: center;">
        <button class="discord-btn" id="discord-subscribe-btn" title="Get notified in Discord before drops">
          <span style="font-size: 1.2rem;">üíú</span> Subscribe to CodePsychee
        </button>
        <button class="theme-toggle" id="theme-toggle" title="Toggle dark mode">
          <span id="theme-icon">üåô</span>
        </button>
      </div>
    </div>

    <h1>üîÆ CodePsychee - Bonus Code Predictions</h1>
    <p style="text-align: center; color: var(--text-secondary); margin-top: -1rem; margin-bottom: 2rem; font-style: italic;">
      Powered by AI pattern recognition ‚Ä¢ Predicting Stake.us Instagram bonus drops
    </p>
    
    <!-- Next Prediction Card -->
    <div class="card prediction-card">
      <h2 style="margin-top: 0;">üéØ Next Predicted Drop</h2>
      <div id="next-prediction">
        <p style="font-size: 1.25rem; margin: 1rem 0;">
          <strong>Date/Time:</strong> <span id="pred-datetime" style="color: var(--accent);"></span>
        </p>
        <p style="font-size: 1.25rem; margin: 1rem 0;">
          <strong>Expected Amount:</strong> <span id="pred-amount" style="color: var(--success);"></span>
        </p>
        <p style="font-size: 1rem; margin: 1rem 0;">
          <strong>Confidence:</strong> <span id="pred-confidence"></span>
        </p>
        <div class="confidence-meter">
          <div class="confidence-fill" id="confidence-bar"></div>
        </div>
        <button class="report-drop-btn" id="report-drop-btn">
          ‚úÖ Report Actual Drop
        </button>
      </div>
    </div>
    
    <!-- Accuracy Metrics Card -->
    <div class="card accuracy-card" id="accuracy-metrics-section">
      <h2 style="margin-top: 0;">üìä Prediction Accuracy Metrics</h2>
      <div class="stat-grid">
        <div class="accuracy-stat">
          <div class="accuracy-value" id="overall-accuracy">--%</div>
          <div class="accuracy-label">Overall Accuracy</div>
        </div>
        <div class="accuracy-stat">
          <div class="accuracy-value" id="verified-predictions">0</div>
          <div class="accuracy-label">Verified Predictions</div>
        </div>
        <div class="accuracy-stat">
          <div class="accuracy-value" id="avg-time-diff">-- min</div>
          <div class="accuracy-label">Avg Time Diff</div>
        </div>
        <div class="accuracy-stat">
          <div class="accuracy-value" id="amount-accuracy">--%</div>
          <div class="accuracy-label">Amount Accuracy</div>
        </div>
      </div>
      
      <div id="accuracy-trend" style="margin-top: 1.5rem; text-align: center; color: var(--text-secondary);">
        <p id="trend-message">Start verifying predictions to see accuracy trends!</p>
      </div>
      
      <div id="recent-verifications-container" style="margin-top: 1.5rem; display: none;">
        <h3>Recent Verifications</h3>
        <ul class="verification-list" id="recent-verifications"></ul>
      </div>
    </div>
    
    <!-- Historical Analysis -->
    <div class="card">
      <h2>üìà Historical Analysis</h2>
      <div class="stat-grid">
        <div class="stat-box">
          <div class="stat-value" id="total-drops">0</div>
          <div class="stat-label">Total Drops</div>
        </div>
        <div class="stat-box">
          <div class="stat-value" id="avg-days">0</div>
          <div class="stat-label">Avg Days Between</div>
        </div>
        <div class="stat-box">
          <div class="stat-value" id="most-common-amount">$0</div>
          <div class="stat-label">Most Common Amount</div>
        </div>
        <div class="stat-box">
          <div class="stat-value" id="recent-frequency">0</div>
          <div class="stat-label">Recent Drops (30d)</div>
        </div>
      </div>
      
      <h3>Day of Week Distribution</h3>
      <div class="chart-container">
        <div class="bar-chart" id="day-chart"></div>
      </div>
      
      <h3>Time of Day Distribution (UTC)</h3>
      <div class="chart-container">
        <div class="time-heatmap" id="time-heatmap"></div>
      </div>
      
      <h3>Bonus Amount Distribution</h3>
      <div class="chart-container">
        <div class="bar-chart" id="amount-chart"></div>
      </div>
    </div>
    
    <!-- Key Insights -->
    <div class="card">
      <h2>üí° Key Insights</h2>
      <div id="insights-container"></div>
    </div>
    
    <!-- 7-Day Predictions -->
    <div class="card">
      <h2>üìÖ Next 7 Days Predictions</h2>
      <ul class="prediction-list" id="weekly-predictions"></ul>
    </div>
    
    <!-- Pattern Analysis -->
    <div class="card">
      <h2>üîç Pattern Analysis</h2>
      <div id="pattern-analysis"></div>
    </div>
  </div>

  <script>
    // Theme toggle functionality
    (function() {
      const themeToggle = document.getElementById('theme-toggle');
      const themeIcon = document.getElementById('theme-icon');
      const html = document.documentElement;
      
      const savedTheme = localStorage.getItem('theme') || 'light';
      html.setAttribute('data-theme', savedTheme);
      updateThemeIcon(savedTheme);
      
      function updateThemeIcon(theme) {
        themeIcon.textContent = theme === 'dark' ? '‚òÄÔ∏è' : 'üåô';
      }
      
      themeToggle.addEventListener('click', () => {
        const currentTheme = html.getAttribute('data-theme');
        const newTheme = currentTheme === 'dark' ? 'light' : 'dark';
        
        html.setAttribute('data-theme', newTheme);
        localStorage.setItem('theme', newTheme);
        updateThemeIcon(newTheme);
      });
    })();

    // Global variables for data
    let historicalDataRaw = null;
    let dataLastUpdated = null;
    let accuracyData = null;
    let currentPrediction = null;
    
    // Load accuracy data from JSON file
    async function loadAccuracyData() {
      try {
        const response = await fetch('prediction-accuracy.json');
        if (!response.ok) {
          throw new Error('Failed to load accuracy data');
        }
        accuracyData = await response.json();
        
        // Also check localStorage for any unsaved data
        const localData = localStorage.getItem('codepsychee_accuracy_local');
        if (localData) {
          const local = JSON.parse(localData);
          // Merge local data with server data
          accuracyData.predictions = [...accuracyData.predictions, ...local.predictions];
          accuracyData.verifications = [...accuracyData.verifications, ...local.verifications];
        }
        
        return true;
      } catch (error) {
        console.error('Error loading accuracy data:', error);
        // Initialize with empty structure
        accuracyData = {
          version: "1.0",
          lastUpdated: new Date().toISOString(),
          predictions: [],
          verifications: [],
          accuracyMetrics: {
            totalPredictions: 0,
            totalVerifications: 0,
            successfulPredictions: 0,
            averageTimeDifferenceMinutes: 0,
            amountAccuracy: 0,
            overallAccuracyRate: 0,
            improvementTrend: []
          }
        };
        
        // Try to load from localStorage as fallback
        const localData = localStorage.getItem('codepsychee_accuracy_local');
        if (localData) {
          const local = JSON.parse(localData);
          accuracyData.predictions = local.predictions || [];
          accuracyData.verifications = local.verifications || [];
        }
        
        return false;
      }
    }
    
    // Fetch historical data from JSON file
    async function loadHistoricalData() {
      try {
        const response = await fetch('bonus-drops-data.json');
        if (!response.ok) {
          throw new Error('Failed to load bonus drops data');
        }
        const data = await response.json();
        dataLastUpdated = new Date(data.lastUpdated);
        
        // Convert JSON to the text format expected by the parser
        historicalDataRaw = data.drops.map(drop => {
          const amount = drop.amount === null ? 'Unknown' : `$${drop.amount}`;
          return `${drop.date} ${drop.time} ‚Äî ${amount}`;
        }).join('\n');
        
        return true;
      } catch (error) {
        console.error('Error loading bonus drops data:', error);
        // Fallback to embedded data if fetch fails
        historicalDataRaw = `2022-09-10 05:00 ‚Äî $10
2023-10-09 05:00 ‚Äî $10
2023-11-14 06:00 ‚Äî $10
2024-01-19 08:00 ‚Äî $10
2024-02-10 05:22 ‚Äî $10
2024-02-20 01:10 ‚Äî $10
2024-03-13 06:23 ‚Äî $10
2024-03-19 03:47 ‚Äî $10
2024-03-26 05:49 ‚Äî $10
2024-04-06 04:45 ‚Äî $10
2024-04-11 03:39 ‚Äî $10
2024-04-16 02:46 ‚Äî $10
2024-04-20 08:39 ‚Äî $10
2024-04-24 02:06 ‚Äî $10
2024-04-29 23:35 ‚Äî $10
2024-05-03 03:34 ‚Äî $10
2024-05-06 03:50 ‚Äî $10
2024-05-09 00:22 ‚Äî $10
2024-05-20 00:48 ‚Äî $10
2024-05-23 00:58 ‚Äî $10
2024-05-27 03:47 ‚Äî $10
2024-06-02 03:57 ‚Äî $10
2024-06-04 04:08 ‚Äî $10
2024-06-06 06:19 ‚Äî $10
2024-06-06 09:53 ‚Äî $10
2024-06-09 05:00 ‚Äî $10
2024-06-11 12:42 ‚Äî $10
2024-06-13 05:13 ‚Äî $10
2024-06-14 04:01 ‚Äî $10
2024-06-19 04:10 ‚Äî $10
2024-06-24 04:08 ‚Äî $10
2024-07-01 03:29 ‚Äî $10
2024-07-10 06:36 ‚Äî Unknown
2024-07-23 05:00 ‚Äî $10
2024-07-30 05:00 ‚Äî $10
2024-07-31 00:34 ‚Äî $10
2024-08-05 04:36 ‚Äî $10
2024-08-15 04:11 ‚Äî $10
2024-08-27 05:00 ‚Äî $11
2024-08-28 04:56 ‚Äî $10
2024-08-31 23:41 ‚Äî $10
2024-09-02 23:41 ‚Äî $10
2024-09-12 23:37 ‚Äî $10
2024-09-17 23:42 ‚Äî $10
2024-09-21 23:42 ‚Äî $10
2024-09-26 02:09 ‚Äî $10
2024-09-29 02:12 ‚Äî Unknown
2024-10-01 00:34 ‚Äî $10
2024-10-04 01:00 ‚Äî Unknown
2024-10-13 00:00 ‚Äî $10
2024-10-15 23:50 ‚Äî $10
2024-10-23 02:45 ‚Äî Unknown
2024-11-13 02:52 ‚Äî Unknown
2024-12-17 03:26 ‚Äî $10
2025-02-05 05:14 ‚Äî $10
2025-02-17 04:30 ‚Äî Unknown
2025-04-04 01:03 ‚Äî Unknown
2025-04-12 07:00 ‚Äî Unknown
2025-04-15 23:57 ‚Äî Unknown
2025-04-28 01:48 ‚Äî $10
2025-05-04 04:51 ‚Äî $10
2025-05-10 03:17 ‚Äî Unknown
2025-05-13 01:08 ‚Äî $10
2025-05-26 01:15 ‚Äî Unknown
2025-05-26 22:01 ‚Äî $10
2025-06-03 02:03 ‚Äî Unknown
2025-06-04 22:50 ‚Äî $10
2025-06-06 03:51 ‚Äî Unknown
2025-06-07 05:00 ‚Äî Unknown
2025-06-10 02:00 ‚Äî Unknown
2025-06-12 01:00 ‚Äî Unknown
2025-06-13 02:00 ‚Äî Unknown
2025-06-15 01:00 ‚Äî $5
2025-06-16 02:00 ‚Äî $5
2025-06-17 03:22 ‚Äî Unknown
2025-06-20 01:00 ‚Äî Unknown
2025-06-22 04:00 ‚Äî $5
2025-06-24 04:37 ‚Äî $10
2025-06-29 00:10 ‚Äî $10
2025-07-01 01:00 ‚Äî $10
2025-07-02 00:20 ‚Äî $5
2025-07-04 01:15 ‚Äî Unknown
2025-07-06 03:00 ‚Äî $5
2025-07-07 03:37 ‚Äî $10
2025-07-09 00:25 ‚Äî $5
2025-07-23 22:26 ‚Äî $5
2025-07-25 00:00 ‚Äî $10
2025-07-30 01:29 ‚Äî $10
2025-08-01 03:38 ‚Äî $5
2025-08-05 00:00 ‚Äî Unknown
2025-08-06 01:52 ‚Äî Unknown
2025-08-08 03:26 ‚Äî $5
2025-08-16 02:04 ‚Äî Unknown
2025-08-16 23:01 ‚Äî $10
2025-08-18 03:21 ‚Äî Unknown
2025-08-21 05:00 ‚Äî $10
2025-08-25 00:24 ‚Äî $5
2025-08-26 02:02 ‚Äî $10
2025-08-27 00:50 ‚Äî $5
2025-08-29 01:45 ‚Äî $5
2025-09-02 01:46 ‚Äî $10
2025-09-02 04:32 ‚Äî $5
2025-09-02 05:00 ‚Äî Unknown
2025-09-03 17:46 ‚Äî $10
2025-09-03 23:23 ‚Äî $5
2025-09-05 00:50 ‚Äî $10
2025-09-06 05:00 ‚Äî $5
2025-09-07 01:51 ‚Äî $10
2025-09-09 02:28 ‚Äî $5
2025-09-09 22:53 ‚Äî $10
2025-09-10 07:10 ‚Äî $10
2025-09-10 23:01 ‚Äî $5
2025-09-11 02:22 ‚Äî $5
2025-09-11 04:58 ‚Äî $10
2025-09-13 04:51 ‚Äî $10
2025-09-14 05:04 ‚Äî Unknown
2025-09-15 07:01 ‚Äî $10
2025-09-16 22:54 ‚Äî $10
2025-09-17 04:22 ‚Äî $10
2025-09-20 02:02 ‚Äî Unknown
2025-09-21 03:13 ‚Äî $10
2025-09-22 23:53 ‚Äî $5
2025-09-25 01:51 ‚Äî $5
2025-09-28 02:05 ‚Äî $5
2025-09-29 04:25 ‚Äî $10
2025-09-30 01:45 ‚Äî $10
2025-09-30 23:25 ‚Äî $5
2025-10-01 01:10 ‚Äî $5
2025-10-01 09:12 ‚Äî Unknown
2025-10-03 00:26 ‚Äî $10
2025-10-03 02:16 ‚Äî $10
2025-10-07 01:16 ‚Äî $10
2025-10-07 21:18 ‚Äî $5
2025-10-08 20:36 ‚Äî $5
2025-10-11 01:50 ‚Äî $5
2025-10-13 01:50 ‚Äî $10
2025-10-13 21:36 ‚Äî $5
2025-10-15 22:32 ‚Äî $10
2025-10-16 00:12 ‚Äî $10
2025-10-18 02:13 ‚Äî $10
2025-10-19 23:40 ‚Äî $5
2025-10-21 00:53 ‚Äî $5
2025-10-22 23:48 ‚Äî $10
2025-10-25 07:00 ‚Äî $10
2025-10-27 02:28 ‚Äî $5
2025-10-28 21:36 ‚Äî $5
2025-10-30 10:30 ‚Äî $5
2025-11-01 02:15 ‚Äî $10
2025-11-02 01:30 ‚Äî $5`;
        dataLastUpdated = new Date('2025-11-02T03:21:00Z');
        return false;
      }
    }

    // Parse historical data
    function parseHistoricalData(data) {
      const lines = data.trim().split('\n');
      const drops = [];
      
      lines.forEach(line => {
        const match = line.match(/(\d{4}-\d{2}-\d{2})\s+(\d{2}:\d{2})\s+[‚Äî\-‚Äì]\s+\$?(\d+|Unknown)/);
        if (match) {
          const [, date, time, amount] = match;
          const datetime = new Date(`${date}T${time}:00Z`);
          drops.push({
            datetime,
            date,
            time,
            amount: amount === 'Unknown' ? null : parseInt(amount),
            dayOfWeek: datetime.getUTCDay(),
            hour: datetime.getUTCHours()
          });
        }
      });
      
      return drops.sort((a, b) => a.datetime - b.datetime);
    }

    // Analyze patterns
    function analyzePatterns(drops) {
      const analysis = {
        totalDrops: drops.length,
        dayOfWeekCounts: [0, 0, 0, 0, 0, 0, 0],
        hourCounts: Array(24).fill(0),
        amountCounts: { 5: 0, 10: 0, 11: 0, unknown: 0 },
        daysBetween: [],
        recentDrops30d: 0,
        recentDrops7d: 0
      };
      
      const now = new Date();
      const thirtyDaysAgo = new Date(now - 30 * 24 * 60 * 60 * 1000);
      const sevenDaysAgo = new Date(now - 7 * 24 * 60 * 60 * 1000);
      
      drops.forEach((drop, i) => {
        // Day of week
        analysis.dayOfWeekCounts[drop.dayOfWeek]++;
        
        // Hour of day
        analysis.hourCounts[drop.hour]++;
        
        // Amount
        if (drop.amount === 5) analysis.amountCounts[5]++;
        else if (drop.amount === 10) analysis.amountCounts[10]++;
        else if (drop.amount === 11) analysis.amountCounts[11]++;
        else analysis.amountCounts.unknown++;
        
        // Days between drops
        if (i > 0) {
          const daysDiff = (drop.datetime - drops[i-1].datetime) / (1000 * 60 * 60 * 24);
          analysis.daysBetween.push(daysDiff);
        }
        
        // Recent activity
        if (drop.datetime >= thirtyDaysAgo) analysis.recentDrops30d++;
        if (drop.datetime >= sevenDaysAgo) analysis.recentDrops7d++;
      });
      
      // Calculate averages (prevent division by zero)
      if (analysis.daysBetween.length > 0) {
        analysis.avgDaysBetween = analysis.daysBetween.reduce((a, b) => a + b, 0) / analysis.daysBetween.length;
        
        // Recent average (last 20 drops)
        const recentDays = analysis.daysBetween.slice(-20);
        if (recentDays.length > 0) {
          analysis.recentAvgDaysBetween = recentDays.reduce((a, b) => a + b, 0) / recentDays.length;
        } else {
          analysis.recentAvgDaysBetween = analysis.avgDaysBetween;
        }
      } else {
        // Fallback defaults if no historical data
        analysis.avgDaysBetween = 2.0;
        analysis.recentAvgDaysBetween = 2.0;
      }
      
      // Find most common day
      const maxDayCount = Math.max(...analysis.dayOfWeekCounts);
      analysis.mostCommonDay = analysis.dayOfWeekCounts.indexOf(maxDayCount);
      
      // Find most common hour
      const maxHourCount = Math.max(...analysis.hourCounts);
      analysis.mostCommonHour = analysis.hourCounts.indexOf(maxHourCount);
      
      // Most common amount
      const amounts = analysis.amountCounts;
      analysis.mostCommonAmount = amounts[10] >= amounts[5] ? 10 : 5;
      
      return analysis;
    }

    // Check if a date is a holiday (major US holidays when bonus drops are more frequent)
    function isHoliday(date) {
      const month = date.getUTCMonth() + 1; // 1-12
      const day = date.getUTCDate();
      
      const holidays = {
        '1-1': 'New Year\'s Day',
        '2-14': 'Valentine\'s Day',
        '3-17': 'St. Patrick\'s Day',
        '7-4': 'Independence Day',
        '10-31': 'Halloween',
        '11-24': 'Black Friday', // Approximate
        '11-25': 'Black Friday Weekend',
        '11-27': 'Thanksgiving Eve',
        '11-28': 'Thanksgiving',
        '11-29': 'Thanksgiving Weekend',
        '12-24': 'Christmas Eve',
        '12-25': 'Christmas',
        '12-31': 'New Year\'s Eve'
      };
      
      const key = `${month}-${day}`;
      return holidays[key] || null;
    }
    
    // Get upcoming holidays in the next N days
    function getUpcomingHolidays(startDate, days) {
      const upcoming = [];
      for (let i = 0; i < days; i++) {
        const checkDate = new Date(startDate.getTime() + i * 24 * 60 * 60 * 1000);
        const holiday = isHoliday(checkDate);
        if (holiday) {
          upcoming.push({ date: checkDate, name: holiday, daysAway: i });
        }
      }
      return upcoming;
    }

    // Generate predictions
    function generatePredictions(drops, analysis) {
      const now = new Date();
      const lastDrop = drops[drops.length - 1];
      
      // Calculate next likely drop time
      let avgInterval = analysis.recentAvgDaysBetween || analysis.avgDaysBetween || 2;
      
      // Adjust for recent frequency increase
      if (analysis.recentDrops7d >= 5) {
        avgInterval = Math.min(avgInterval, 1.5); // More frequent recent pattern
      }
      
      // Predict next drop
      let nextDropTime = new Date(lastDrop.datetime.getTime() + avgInterval * 24 * 60 * 60 * 1000);
      
      // Check for holidays in the next 7 days and adjust predictions
      const upcomingHolidays = getUpcomingHolidays(now, 7);
      let holidayBoost = 1.0;
      let nearestHoliday = null;
      
      // If there's a holiday coming up, increase drop likelihood
      if (upcomingHolidays.length > 0) {
        nearestHoliday = upcomingHolidays[0];
        // On or near holidays, drops are more frequent (reduce interval)
        if (nearestHoliday.daysAway <= 1) {
          avgInterval = Math.max(avgInterval * 0.5, 0.5); // Up to 50% more frequent
          holidayBoost = 1.5;
        } else if (nearestHoliday.daysAway <= 3) {
          avgInterval = Math.max(avgInterval * 0.75, 0.75); // 25% more frequent
          holidayBoost = 1.25;
        }
        
        // Re-calculate with holiday adjustment
        nextDropTime = new Date(lastDrop.datetime.getTime() + avgInterval * 24 * 60 * 60 * 1000);
      }
      
      // Store holiday info for display
      const holidayInfo = upcomingHolidays.length > 0 ? upcomingHolidays : null;
      
      // Adjust to most common hour (deterministic based on last drop)
      nextDropTime.setUTCHours(analysis.mostCommonHour);
      nextDropTime.setUTCMinutes(lastDrop.datetime.getUTCMinutes());
      
      // Predict amount (based on recent patterns)
      const recent25 = drops.slice(-25).filter(d => d.amount !== null);
      const recent5count = recent25.filter(d => d.amount === 5).length;
      const recent10count = recent25.filter(d => d.amount === 10).length;
      
      let predictedAmount = 10; // Default
      let amountConfidence = 0.6;
      
      if (recent10count > recent5count * 1.5) {
        predictedAmount = 10;
        amountConfidence = 0.75;
      } else if (recent5count > recent10count) {
        predictedAmount = 5;
        amountConfidence = 0.65;
      } else {
        // Mixed pattern - alternate based on last drop (handle null amount)
        predictedAmount = (lastDrop.amount === 5) ? 10 : (lastDrop.amount === 10) ? 5 : 10;
        amountConfidence = 0.55;
      }
      
      // Calculate overall confidence (prevent NaN)
      const avgDiff = Math.abs((analysis.avgDaysBetween || 2) - (analysis.recentAvgDaysBetween || 2));
      const frequencyConsistency = 1 / (1 + avgDiff);
      const recentActivityBoost = Math.min(analysis.recentDrops7d / 7, 1);
      const baseConfidence = 0.65;
      
      // Holiday boost increases confidence
      const holidayConfidenceBoost = holidayBoost > 1.0 ? 0.1 : 0;
      
      const overallConfidence = Math.min(
        (baseConfidence + frequencyConsistency * 0.2 + recentActivityBoost * 0.15 + holidayConfidenceBoost) * amountConfidence,
        0.95
      );
      
      // Generate 7-day predictions (deterministic)
      const weeklyPredictions = [];
      for (let i = 0; i < 7; i++) {
        const predDate = new Date(nextDropTime.getTime() + i * avgInterval * 24 * 60 * 60 * 1000);
        // Vary hours based on pattern: cycle through common drop hours
        const hourVariation = (i % 3) - 1; // -1, 0, 1 hour variance
        predDate.setUTCHours(analysis.mostCommonHour + hourVariation);
        predDate.setUTCMinutes((lastDrop.datetime.getUTCMinutes() + i * 7) % 60);
        
        const amount = i % 2 === 0 ? predictedAmount : (predictedAmount === 10 ? 5 : 10);
        const confidence = overallConfidence * (1 - i * 0.05); // Decrease confidence for later predictions
        
        weeklyPredictions.push({
          datetime: predDate,
          amount,
          confidence: Math.max(confidence, 0.4)
        });
      }
      
      return {
        nextDrop: {
          datetime: nextDropTime,
          amount: predictedAmount,
          confidence: overallConfidence,
          holidayInfo: nearestHoliday
        },
        weeklyPredictions,
        upcomingHolidays: holidayInfo
      };
    }

    // Store prediction for later verification
    function storePrediction(prediction) {
      const predictionRecord = {
        id: `pred_${Date.now()}_${Math.random().toString(36).substring(2, 11)}`,
        predictionDate: new Date().toISOString(),
        predictedDropDate: prediction.datetime.toISOString(),
        predictedAmount: prediction.amount,
        confidence: prediction.confidence,
        verified: false,
        verificationId: null
      };
      
      accuracyData.predictions.push(predictionRecord);
      currentPrediction = predictionRecord;
      
      // Save to localStorage as backup
      saveAccuracyDataLocally();
      
      return predictionRecord;
    }
    
    // Save accuracy data to localStorage
    function saveAccuracyDataLocally() {
      try {
        const localData = {
          predictions: accuracyData.predictions,
          verifications: accuracyData.verifications,
          lastUpdated: new Date().toISOString()
        };
        localStorage.setItem('codepsychee_accuracy_local', JSON.stringify(localData));
      } catch (error) {
        console.error('Error saving to localStorage:', error);
      }
    }
    
    // Calculate accuracy metrics
    function calculateAccuracyMetrics() {
      const verifications = accuracyData.verifications;
      const predictions = accuracyData.predictions;
      
      if (verifications.length === 0) {
        return {
          totalPredictions: predictions.length,
          totalVerifications: 0,
          successfulPredictions: 0,
          averageTimeDifferenceMinutes: 0,
          amountAccuracy: 0,
          overallAccuracyRate: 0,
          improvementTrend: []
        };
      }
      
      // Calculate time accuracy (predictions within 3 hours = successful)
      const timeDiffs = verifications
        .filter(v => v.timeDifferenceMinutes !== null)
        .map(v => Math.abs(v.timeDifferenceMinutes));
      
      const avgTimeDiff = timeDiffs.length > 0 
        ? timeDiffs.reduce((a, b) => a + b, 0) / timeDiffs.length 
        : 0;
      
      const successfulTime = verifications.filter(v => 
        v.timeDifferenceMinutes !== null && Math.abs(v.timeDifferenceMinutes) <= 180
      ).length;
      
      // Calculate amount accuracy
      const amountMatches = verifications.filter(v => v.amountMatch === true).length;
      const amountAccuracy = verifications.length > 0 
        ? (amountMatches / verifications.length) * 100 
        : 0;
      
      // Overall accuracy (time + amount combined)
      const overallSuccess = verifications.filter(v => 
        v.amountMatch === true && v.timeDifferenceMinutes !== null && Math.abs(v.timeDifferenceMinutes) <= 180
      ).length;
      
      const overallAccuracyRate = verifications.length > 0 
        ? (overallSuccess / verifications.length) * 100 
        : 0;
      
      // Calculate improvement trend (last 10 verifications vs previous 10)
      const recentVerifications = verifications.slice(-10);
      const previousVerifications = verifications.slice(-20, -10);
      
      const recentAccuracy = recentVerifications.length > 0
        ? (recentVerifications.filter(v => v.amountMatch && Math.abs(v.timeDifferenceMinutes || 0) <= 180).length / recentVerifications.length) * 100
        : 0;
      
      const previousAccuracy = previousVerifications.length > 0
        ? (previousVerifications.filter(v => v.amountMatch && Math.abs(v.timeDifferenceMinutes || 0) <= 180).length / previousVerifications.length) * 100
        : 0;
      
      const improvementTrend = recentAccuracy - previousAccuracy;
      
      return {
        totalPredictions: predictions.length,
        totalVerifications: verifications.length,
        successfulPredictions: overallSuccess,
        averageTimeDifferenceMinutes: avgTimeDiff,
        amountAccuracy: amountAccuracy,
        overallAccuracyRate: overallAccuracyRate,
        improvementTrend: improvementTrend,
        recentAccuracy: recentAccuracy,
        previousAccuracy: previousAccuracy
      };
    }
    
    // Display accuracy metrics
    function displayAccuracyMetrics() {
      const metrics = calculateAccuracyMetrics();
      
      document.getElementById('overall-accuracy').textContent = 
        metrics.totalVerifications > 0 ? `${Math.round(metrics.overallAccuracyRate)}%` : '--%';
      
      document.getElementById('verified-predictions').textContent = metrics.totalVerifications;
      
      document.getElementById('avg-time-diff').textContent = 
        metrics.totalVerifications > 0 ? `${Math.round(metrics.averageTimeDifferenceMinutes)} min` : '-- min';
      
      document.getElementById('amount-accuracy').textContent = 
        metrics.totalVerifications > 0 ? `${Math.round(metrics.amountAccuracy)}%` : '--%';
      
      // Display trend
      const trendMessage = document.getElementById('trend-message');
      if (metrics.totalVerifications === 0) {
        trendMessage.innerHTML = 'Start verifying predictions to see accuracy trends!';
      } else if (metrics.totalVerifications < 10) {
        trendMessage.innerHTML = `üìà Keep verifying! Need at least 10 verifications to show trends. (${metrics.totalVerifications}/10)`;
      } else {
        const trendIcon = metrics.improvementTrend > 0 ? 'üìà' : metrics.improvementTrend < 0 ? 'üìâ' : '‚û°Ô∏è';
        const trendClass = metrics.improvementTrend > 0 ? 'trend-up' : metrics.improvementTrend < 0 ? 'trend-down' : '';
        const trendText = Math.abs(metrics.improvementTrend).toFixed(1);
        
        trendMessage.innerHTML = `
          ${trendIcon} <strong>Accuracy Trend:</strong> 
          <span class="${trendClass}">${metrics.improvementTrend > 0 ? '+' : ''}${trendText}%</span> 
          compared to previous predictions
          <br>
          <small style="opacity: 0.8;">Recent: ${Math.round(metrics.recentAccuracy)}% ‚Ä¢ Previous: ${Math.round(metrics.previousAccuracy)}%</small>
        `;
      }
      
      // Display recent verifications
      displayRecentVerifications();
    }
    
    // Display recent verifications
    function displayRecentVerifications() {
      const verifications = accuracyData.verifications.slice(-5).reverse();
      const container = document.getElementById('recent-verifications-container');
      const list = document.getElementById('recent-verifications');
      
      if (verifications.length === 0) {
        container.style.display = 'none';
        return;
      }
      
      container.style.display = 'block';
      list.innerHTML = '';
      
      verifications.forEach(verification => {
        const actualDate = new Date(verification.actualDropDate);
        const dateStr = actualDate.toLocaleString('en-US', {
          timeZone: 'UTC',
          month: 'short',
          day: 'numeric',
          hour: '2-digit',
          minute: '2-digit'
        });
        
        const timeDiff = verification.timeDifferenceMinutes;
        const amountMatch = verification.amountMatch;
        
        let accuracyClass = 'accuracy-excellent';
        let accuracyLabel = 'Excellent';
        
        if (timeDiff !== null) {
          const absDiff = Math.abs(timeDiff);
          if (absDiff <= 60 && amountMatch) {
            accuracyClass = 'accuracy-excellent';
            accuracyLabel = 'Excellent';
          } else if (absDiff <= 180 && amountMatch) {
            accuracyClass = 'accuracy-good';
            accuracyLabel = 'Good';
          } else if (absDiff <= 360) {
            accuracyClass = 'accuracy-fair';
            accuracyLabel = 'Fair';
          } else {
            accuracyClass = 'accuracy-poor';
            accuracyLabel = 'Needs Improvement';
          }
        }
        
        const li = document.createElement('li');
        li.className = `verification-item ${!amountMatch || (timeDiff && Math.abs(timeDiff) > 180) ? 'inaccurate' : ''}`;
        li.innerHTML = `
          <div class="verification-header">
            <strong>${dateStr} UTC</strong>
            <span class="accuracy-badge ${accuracyClass}">${accuracyLabel}</span>
          </div>
          <div class="verification-details">
            üí∞ Actual: $${verification.actualAmount} ‚Ä¢ 
            ${timeDiff !== null ? `‚è±Ô∏è Time diff: ${Math.abs(timeDiff)} min ${timeDiff > 0 ? 'late' : 'early'}` : 'No prediction match'} ‚Ä¢ 
            ${amountMatch ? '‚úÖ Amount matched' : '‚ùå Amount mismatch'}
          </div>
        `;
        list.appendChild(li);
      });
    }
    
    // Handle verification form submission
    function handleVerificationSubmit(e) {
      e.preventDefault();
      
      const date = document.getElementById('actual-drop-date').value;
      const time = document.getElementById('actual-drop-time').value;
      const amountSelect = document.getElementById('actual-amount').value;
      const notes = document.getElementById('notes').value;
      
      const actualAmount = amountSelect === 'other' ? null : parseInt(amountSelect, 10);
      const actualDropDate = new Date(`${date}T${time}:00Z`);
      
      // Find matching prediction (within 24 hours)
      let matchedPrediction = null;
      let timeDiff = null;
      
      for (const pred of accuracyData.predictions) {
        if (pred.verified) continue;
        
        const predDate = new Date(pred.predictedDropDate);
        const diff = (actualDropDate - predDate) / (1000 * 60); // minutes
        
        if (Math.abs(diff) <= 24 * 60) { // Within 24 hours
          matchedPrediction = pred;
          timeDiff = diff;
          break;
        }
      }
      
      // Create verification record
      const verification = {
        id: `verif_${Date.now()}_${Math.random().toString(36).substring(2, 11)}`,
        verificationDate: new Date().toISOString(),
        actualDropDate: actualDropDate.toISOString(),
        actualAmount: actualAmount,
        predictionId: matchedPrediction ? matchedPrediction.id : null,
        timeDifferenceMinutes: timeDiff,
        amountMatch: matchedPrediction && actualAmount !== null ? matchedPrediction.predictedAmount === actualAmount : false,
        addedToHistorical: false,
        notes: notes || null
      };
      
      // Mark prediction as verified
      if (matchedPrediction) {
        matchedPrediction.verified = true;
        matchedPrediction.verificationId = verification.id;
      }
      
      // Add to verifications
      accuracyData.verifications.push(verification);
      
      // Save locally
      saveAccuracyDataLocally();
      
      // Update metrics display
      displayAccuracyMetrics();
      
      // Show success message
      const accuracy = verification.amountMatch && timeDiff && Math.abs(timeDiff) <= 180 ? 'accurate' : 'recorded';
      alert(`‚úÖ Verification ${accuracy}!\n\n` +
            `Actual: $${actualAmount ?? 'Unknown'} at ${actualDropDate.toLocaleString('en-US', { timeZone: 'UTC' })} UTC\n` +
            (timeDiff !== null ? `Time difference: ${Math.abs(Math.round(timeDiff))} minutes ${timeDiff > 0 ? 'later' : 'earlier'} than predicted\n` : '') +
            (verification.amountMatch ? '‚úÖ Amount matched prediction!' : '‚ùå Amount differed from prediction') +
            '\n\nThank you for helping improve CodePsychee!'
      );
      
      // Close modal and reset form
      document.getElementById('verification-modal').style.display = 'none';
      e.target.reset();
      
      // Suggest adding to historical data
      if (actualAmount !== null && !verification.addedToHistorical) {
        setTimeout(() => {
          if (confirm('Would you like to add this verified drop to the historical database?\n\n' +
                     'This will help improve future predictions for everyone!')) {
            addVerifiedDropToHistorical(verification);
          }
        }, 1000);
      }
    }
    
    // Add verified drop to historical database
    function addVerifiedDropToHistorical(verification) {
      const actualDate = new Date(verification.actualDropDate);
      const dateStr = actualDate.toISOString().split('T')[0];
      const timeStr = actualDate.toISOString().split('T')[1].substring(0, 5);
      
      // Add to the historicalDataRaw string
      const newEntry = `${dateStr} ${timeStr} ‚Äî $${verification.actualAmount ?? 'Unknown'}`;
      historicalDataRaw += '\n' + newEntry;
      
      // Mark as added
      verification.addedToHistorical = true;
      saveAccuracyDataLocally();
      
      // Refresh predictions with new data
      initializePredictions();
      
      alert('‚úÖ Verified drop added to historical database!\n\nPredictions have been recalculated with the new data.');
      
      // Note: In a full implementation, this would also update bonus-drops-data.json on the server
      console.log('Note: In production, this would update bonus-drops-data.json on the server');
    }
    
    // Display data freshness indicator
    function displayDataFreshness() {
      if (!dataLastUpdated) return;
      
      const now = new Date();
      const hoursSinceUpdate = (now - dataLastUpdated) / (1000 * 60 * 60);
      const daysSinceUpdate = Math.floor(hoursSinceUpdate / 24);
      
      let freshnessText = '';
      let freshnessClass = '';
      
      if (hoursSinceUpdate < 24) {
        freshnessText = `Updated ${Math.floor(hoursSinceUpdate)}h ago`;
        freshnessClass = 'badge-high';
      } else if (daysSinceUpdate < 3) {
        freshnessText = `Updated ${daysSinceUpdate} day${daysSinceUpdate > 1 ? 's' : ''} ago`;
        freshnessClass = 'badge-medium';
      } else {
        freshnessText = `Updated ${daysSinceUpdate} days ago`;
        freshnessClass = 'badge-low';
      }
      
      const dateStr = dataLastUpdated.toLocaleString('en-US', {
        timeZone: 'UTC',
        month: 'short',
        day: 'numeric',
        year: 'numeric',
        hour: '2-digit',
        minute: '2-digit',
        timeZoneName: 'short'
      });
      
      // Add freshness indicator after the subtitle
      const subtitle = document.querySelector('h1 + p');
      if (subtitle && !document.getElementById('data-freshness')) {
        const freshnessDiv = document.createElement('div');
        freshnessDiv.id = 'data-freshness';
        freshnessDiv.style.textAlign = 'center';
        freshnessDiv.style.marginTop = '-1rem';
        freshnessDiv.style.marginBottom = '2rem';
        freshnessDiv.innerHTML = `
          <span class="badge ${freshnessClass}" style="font-size: 0.85rem; padding: 0.4rem 1rem;">
            üìä ${freshnessText} ‚Ä¢ ${dateStr}
          </span>
          <button id="refresh-data-btn" class="refresh-btn">
            üîÑ Refresh
          </button>
        `;
        subtitle.after(freshnessDiv);
        
        // Add refresh button handler
        document.getElementById('refresh-data-btn').addEventListener('click', async () => {
          const btn = document.getElementById('refresh-data-btn');
          btn.textContent = '‚è≥ Refreshing...';
          btn.disabled = true;
          
          await loadHistoricalData();
          initializePredictions();
          
          btn.textContent = '‚úì Refreshed';
          setTimeout(() => {
            btn.textContent = 'üîÑ Refresh';
            btn.disabled = false;
          }, 2000);
        });
      }
    }
    
    // Display functions
    function displayStats(analysis) {
      document.getElementById('total-drops').textContent = analysis.totalDrops;
      document.getElementById('avg-days').textContent = (analysis.avgDaysBetween || 0).toFixed(1);
      document.getElementById('most-common-amount').textContent = `$${analysis.mostCommonAmount}`;
      document.getElementById('recent-frequency').textContent = analysis.recentDrops30d;
    }

    function displayDayChart(analysis) {
      const days = ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'];
      const maxCount = Math.max(...analysis.dayOfWeekCounts);
      const container = document.getElementById('day-chart');
      
      container.innerHTML = '';
      analysis.dayOfWeekCounts.forEach((count, i) => {
        const height = (count / maxCount) * 100;
        const bar = document.createElement('div');
        bar.className = 'bar';
        bar.style.height = `${height}%`;
        bar.innerHTML = `
          <span class="bar-value">${count}</span>
          <span class="bar-label">${days[i]}</span>
        `;
        container.appendChild(bar);
      });
    }

    function displayTimeHeatmap(analysis) {
      const container = document.getElementById('time-heatmap');
      const maxCount = Math.max(...analysis.hourCounts);
      
      container.innerHTML = '';
      
      // Group hours in 2-hour blocks
      for (let i = 0; i < 24; i += 2) {
        const count = analysis.hourCounts[i] + analysis.hourCounts[i + 1];
        const intensity = count / (maxCount * 2);
        const cell = document.createElement('div');
        cell.className = 'heatmap-cell';
        
        // Color gradient based on intensity
        const hue = 200 + intensity * 60; // Blue to green
        const lightness = 65 - intensity * 30;
        cell.style.background = `hsl(${hue}, 70%, ${lightness}%)`;
        cell.textContent = `${i}:00`;
        cell.title = `${i}:00-${i+2}:00: ${count} drops`;
        
        container.appendChild(cell);
      }
    }

    function displayAmountChart(analysis) {
      const container = document.getElementById('amount-chart');
      const amounts = [
        { label: '$5', count: analysis.amountCounts[5] },
        { label: '$10', count: analysis.amountCounts[10] },
        { label: '$11', count: analysis.amountCounts[11] },
        { label: 'Unknown', count: analysis.amountCounts.unknown }
      ];
      
      const maxCount = Math.max(...amounts.map(a => a.count));
      
      container.innerHTML = '';
      amounts.forEach(({ label, count }) => {
        const height = (count / maxCount) * 100;
        const bar = document.createElement('div');
        bar.className = 'bar';
        bar.style.height = `${height}%`;
        bar.innerHTML = `
          <span class="bar-value">${count}</span>
          <span class="bar-label">${label}</span>
        `;
        container.appendChild(bar);
      });
    }

    function displayPrediction(prediction) {
      const datetime = prediction.datetime.toLocaleString('en-US', {
        timeZone: 'UTC',
        weekday: 'long',
        year: 'numeric',
        month: 'long',
        day: 'numeric',
        hour: '2-digit',
        minute: '2-digit',
        timeZoneName: 'short'
      });
      
      document.getElementById('pred-datetime').textContent = datetime;
      document.getElementById('pred-amount').textContent = `$${prediction.amount}`;
      
      const confidencePercent = Math.round(prediction.confidence * 100);
      const confidenceLabel = confidencePercent >= 70 ? 'High' : confidencePercent >= 50 ? 'Medium' : 'Low';
      const badgeClass = confidencePercent >= 70 ? 'badge-high' : confidencePercent >= 50 ? 'badge-medium' : 'badge-low';
      
      // Add holiday indicator if applicable
      let holidayBadge = '';
      if (prediction.holidayInfo) {
        const daysText = prediction.holidayInfo.daysAway === 0 ? 'TODAY' : 
                        prediction.holidayInfo.daysAway === 1 ? 'TOMORROW' : 
                        `in ${prediction.holidayInfo.daysAway} days`;
        holidayBadge = `<br><span class="badge badge-holiday" style="margin-top: 0.5rem;">üéâ ${prediction.holidayInfo.name} ${daysText} - Higher drop frequency expected!</span>`;
      }
      
      document.getElementById('pred-confidence').innerHTML = `
        <span class="badge ${badgeClass}">${confidenceLabel} - ${confidencePercent}%</span>${holidayBadge}
      `;
      
      const confidenceBar = document.getElementById('confidence-bar');
      confidenceBar.style.width = `${confidencePercent}%`;
      confidenceBar.textContent = `${confidencePercent}%`;
    }

    function displayWeeklyPredictions(predictions) {
      const container = document.getElementById('weekly-predictions');
      container.innerHTML = '';
      
      predictions.forEach(pred => {
        const dateStr = pred.datetime.toLocaleDateString('en-US', {
          timeZone: 'UTC',
          weekday: 'short',
          month: 'short',
          day: 'numeric',
          hour: '2-digit',
          minute: '2-digit'
        });
        
        const confidencePercent = Math.round(pred.confidence * 100);
        
        const li = document.createElement('li');
        li.className = 'prediction-item';
        li.innerHTML = `
          <span class="prediction-date">${dateStr} UTC</span>
          <span class="prediction-amount">$${pred.amount}</span>
          <span class="prediction-confidence">${confidencePercent}% confidence</span>
        `;
        container.appendChild(li);
      });
    }

    function displayInsights(drops, analysis, predictions) {
      const container = document.getElementById('insights-container');
      const insights = [];
      
      // Holiday insight - show first if there's an upcoming holiday
      if (predictions && predictions.upcomingHolidays && predictions.upcomingHolidays.length > 0) {
        const holiday = predictions.upcomingHolidays[0];
        const daysText = holiday.daysAway === 0 ? 'TODAY' : 
                        holiday.daysAway === 1 ? 'tomorrow' : 
                        `in ${holiday.daysAway} days`;
        insights.push(`üéâ <strong>Holiday Alert:</strong> ${holiday.name} is ${daysText}! Bonus drops typically occur more frequently around holidays - expect up to 2x normal frequency.`);
      }
      
      // Frequency insight
      if (analysis.recentAvgDaysBetween < analysis.avgDaysBetween) {
        insights.push(`üìà <strong>Increasing Frequency:</strong> Recent drops are occurring more frequently (every ${analysis.recentAvgDaysBetween.toFixed(1)} days) compared to historical average (${analysis.avgDaysBetween.toFixed(1)} days).`);
      }
      
      // Day of week insight
      const days = ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'];
      insights.push(`üìÖ <strong>Preferred Day:</strong> Most drops occur on ${days[analysis.mostCommonDay]} (${analysis.dayOfWeekCounts[analysis.mostCommonDay]} drops).`);
      
      // Time insight
      insights.push(`‚è∞ <strong>Peak Time:</strong> Most drops happen around ${analysis.mostCommonHour}:00 UTC.`);
      
      // Amount insight
      const recentKnown = drops.slice(-30).filter(d => d.amount !== null);
      const recent5 = recentKnown.filter(d => d.amount === 5).length;
      const recent10 = recentKnown.filter(d => d.amount === 10).length;
      
      if (recent5 > 0 && recent10 > 0) {
        const ratio = (recent10 / recent5).toFixed(1);
        insights.push(`üí∞ <strong>Amount Pattern:</strong> In the last 30 known drops, $10 bonuses are ${ratio}x more common than $5 bonuses.`);
      }
      
      // Recent activity
      if (analysis.recentDrops7d >= 5) {
        insights.push(`üî• <strong>High Activity:</strong> There have been ${analysis.recentDrops7d} drops in the last 7 days, indicating an active period.`);
      }
      
      container.innerHTML = insights.map(i => `<div class="insight-box">${i}</div>`).join('');
    }

    function displayPatternAnalysis(drops, analysis) {
      const container = document.getElementById('pattern-analysis');
      
      // Calculate pattern metrics
      const recentDrops = drops.slice(-20);
      const timeGaps = [];
      
      for (let i = 1; i < recentDrops.length; i++) {
        const gap = (recentDrops[i].datetime - recentDrops[i-1].datetime) / (1000 * 60 * 60);
        timeGaps.push(gap);
      }
      
      // Guard against empty timeGaps array
      if (timeGaps.length === 0) {
        container.innerHTML = '<p style="color: var(--text-secondary);">Insufficient data for pattern analysis.</p>';
        return;
      }
      
      const avgGap = timeGaps.reduce((a, b) => a + b, 0) / timeGaps.length;
      const minGap = Math.min(...timeGaps);
      const maxGap = Math.max(...timeGaps);
      
      container.innerHTML = `
        <div class="stat-grid">
          <div class="stat-box">
            <div class="stat-value">${avgGap.toFixed(1)}h</div>
            <div class="stat-label">Avg Time Gap (20 recent)</div>
          </div>
          <div class="stat-box">
            <div class="stat-value">${minGap.toFixed(1)}h</div>
            <div class="stat-label">Shortest Gap</div>
          </div>
          <div class="stat-box">
            <div class="stat-value">${maxGap.toFixed(1)}h</div>
            <div class="stat-label">Longest Gap</div>
          </div>
          <div class="stat-box">
            <div class="stat-value">${((maxGap - minGap) / avgGap * 100).toFixed(0)}%</div>
            <div class="stat-label">Variability</div>
          </div>
        </div>
        
        <div style="margin-top: 1.5rem;">
          <h3>Pattern Consistency</h3>
          <p style="color: var(--text-secondary);">
            The drop pattern shows ${((maxGap - minGap) / avgGap * 100) < 100 ? 'moderate' : 'high'} variability. 
            Recent drops have been occurring approximately every ${avgGap.toFixed(1)} hours.
            ${analysis.recentDrops7d >= 5 ? ' The high frequency suggests an active promotional period.' : ''}
          </p>
        </div>
      `;
    }

    // Main initialization function
    function initializePredictions() {
      const drops = parseHistoricalData(historicalDataRaw);
      const analysis = analyzePatterns(drops);
      const predictions = generatePredictions(drops, analysis);
      
      displayStats(analysis);
      displayDayChart(analysis);
      displayTimeHeatmap(analysis);
      displayAmountChart(analysis);
      displayPrediction(predictions.nextDrop);
      displayWeeklyPredictions(predictions.weeklyPredictions);
      displayInsights(drops, analysis, predictions);
      displayPatternAnalysis(drops, analysis);
      displayDataFreshness();
      
      // Store prediction for tracking
      if (accuracyData) {
        storePrediction(predictions.nextDrop);
      }
      
      // Display accuracy metrics
      if (accuracyData) {
        displayAccuracyMetrics();
      }
      
      // Discord subscription functionality (only initialize once)
      if (!document.querySelector('#discord-subscribe-form').hasAttribute('data-initialized')) {
        initializeDiscordSubscription(predictions);
        document.querySelector('#discord-subscribe-form').setAttribute('data-initialized', 'true');
      }
      
      // Initialize verification modal (only once)
      if (!document.getElementById('verification-modal').hasAttribute('data-initialized')) {
        initializeVerificationModal();
        document.getElementById('verification-modal').setAttribute('data-initialized', 'true');
      }
    }
    
    // Initialize verification modal
    function initializeVerificationModal() {
      const modal = document.getElementById('verification-modal');
      const openBtn = document.getElementById('report-drop-btn');
      const closeBtn = document.getElementById('verification-modal-close');
      const form = document.getElementById('verification-form');
      
      openBtn.addEventListener('click', () => {
        // Pre-fill with current date/time
        const now = new Date();
        const dateStr = now.toISOString().split('T')[0];
        const timeStr = now.toISOString().split('T')[1].substring(0, 5);
        
        document.getElementById('actual-drop-date').value = dateStr;
        document.getElementById('actual-drop-time').value = timeStr;
        
        modal.style.display = 'flex';
      });
      
      closeBtn.addEventListener('click', () => {
        modal.style.display = 'none';
      });
      
      modal.addEventListener('click', (e) => {
        if (e.target === modal) {
          modal.style.display = 'none';
        }
      });
      
      form.addEventListener('submit', handleVerificationSubmit);
    }
    
    // Initialize - Load data and run predictions
    document.addEventListener('DOMContentLoaded', async () => {
      // Show loading indicator
      const container = document.querySelector('.container');
      const loadingDiv = document.createElement('div');
      loadingDiv.id = 'loading-indicator';
      loadingDiv.style.textAlign = 'center';
      loadingDiv.style.padding = '2rem';
      loadingDiv.style.fontSize = '1.2rem';
      loadingDiv.style.color = 'var(--text-secondary)';
      loadingDiv.innerHTML = '‚è≥ Loading bonus drop data...';
      container.insertBefore(loadingDiv, container.children[1]);
      
      // Load data
      await Promise.all([
        loadHistoricalData(),
        loadAccuracyData()
      ]);
      
      // Remove loading indicator
      loadingDiv.remove();
      
      // Initialize predictions
      initializePredictions();
      
      // Auto-refresh every 5 minutes to check for data updates
      setInterval(async () => {
        const oldLastUpdated = dataLastUpdated ? dataLastUpdated.getTime() : 0;
        await Promise.all([
          loadHistoricalData(),
          loadAccuracyData()
        ]);
        
        // Only reinitialize if data changed
        if (dataLastUpdated && dataLastUpdated.getTime() !== oldLastUpdated) {
          console.log('New data detected, refreshing predictions...');
          initializePredictions();
        }
      }, 5 * 60 * 1000); // 5 minutes
    });
    
    // Discord Subscription System
    function initializeDiscordSubscription(predictions) {
      const modal = document.getElementById('discord-modal');
      const openBtn = document.getElementById('discord-subscribe-btn');
      const closeBtn = document.getElementById('discord-modal-close');
      const form = document.getElementById('discord-subscribe-form');
      
      openBtn.addEventListener('click', () => {
        modal.style.display = 'flex';
      });
      
      closeBtn.addEventListener('click', () => {
        modal.style.display = 'none';
      });
      
      modal.addEventListener('click', (e) => {
        if (e.target === modal) {
          modal.style.display = 'none';
        }
      });
      
      form.addEventListener('submit', async (e) => {
        e.preventDefault();
        
        const discordUsername = document.getElementById('discord-username').value;
        const submitBtn = form.querySelector('button[type="submit"]');
        
        submitBtn.disabled = true;
        submitBtn.textContent = 'Subscribing...';
        
        try {
          // Store subscription locally
          const subscription = {
            discordUsername,
            subscribedAt: new Date().toISOString(),
            nextPrediction: predictions.nextDrop.datetime,
            notificationSent: false
          };
          
          localStorage.setItem('codepsychee_subscription', JSON.stringify(subscription));
          
          // Show success message
          alert(`üîÆ CodePsychee Subscription Active!\n\nYou'll receive a Discord notification approximately 1 hour before the predicted drop.\n\nNext prediction: ${predictions.nextDrop.datetime.toLocaleString('en-US', { timeZone: 'UTC' })} UTC\n\nNote: Make sure you're in the CollectClock Discord server to receive notifications!`);
          
          modal.style.display = 'none';
          form.reset();
          
          // Update button to show subscribed state
          openBtn.innerHTML = '<span style="font-size: 1.2rem;">‚úÖ</span> Subscribed to CodePsychee';
          openBtn.style.background = 'linear-gradient(135deg, #10b981, #059669)';
          
          // Schedule check for upcoming notifications
          scheduleNotificationCheck(subscription);
          
        } catch (error) {
          alert('Error subscribing. Please try again.');
          console.error('Subscription error:', error);
        } finally {
          submitBtn.disabled = false;
          submitBtn.textContent = 'üîÆ Subscribe';
        }
      });
      
      // Check if already subscribed
      const existingSubscription = localStorage.getItem('codepsychee_subscription');
      if (existingSubscription) {
        const sub = JSON.parse(existingSubscription);
        openBtn.innerHTML = '<span style="font-size: 1.2rem;">‚úÖ</span> Subscribed to CodePsychee';
        openBtn.style.background = 'linear-gradient(135deg, #10b981, #059669)';
        scheduleNotificationCheck(sub);
      }
    }
    
    // Schedule notification check
    function scheduleNotificationCheck(subscription) {
      const predictionTime = new Date(subscription.nextPrediction);
      const oneHourBefore = new Date(predictionTime.getTime() - 60 * 60 * 1000);
      const now = new Date();
      
      if (now >= oneHourBefore && now < predictionTime && !subscription.notificationSent) {
        // Send notification via Discord webhook
        sendDiscordNotification(subscription);
      }
      
      // Check again in 5 minutes
      setTimeout(() => {
        const currentSub = localStorage.getItem('codepsychee_subscription');
        if (currentSub) {
          scheduleNotificationCheck(JSON.parse(currentSub));
        }
      }, 5 * 60 * 1000);
    }
    
    // Send Discord webhook notification
    async function sendDiscordNotification(subscription) {
      // Webhook URL would be configured server-side for security
      // This is a placeholder that demonstrates the structure
      const webhookData = {
        content: `üîÆ **CodePsychee Prediction Alert** üîÆ`,
        embeds: [{
          title: "Bonus Code Drop Predicted Soon!",
          description: `A Stake.us Instagram bonus code drop is predicted within the next hour!`,
          color: 5814783, // Purple color
          fields: [
            {
              name: "üìÖ Predicted Time",
              value: new Date(subscription.nextPrediction).toLocaleString('en-US', { timeZone: 'UTC' }) + ' UTC',
              inline: false
            },
            {
              name: "üîó Check Predictions",
              value: "[View CodePsychee Dashboard](https://jmenichole.github.io/CollectClock/predictions.html)",
              inline: false
            }
          ],
          footer: {
            text: "CodePsychee ‚Ä¢ AI-Powered Predictions"
          },
          timestamp: new Date().toISOString()
        }]
      };
      
      // Mark as sent
      subscription.notificationSent = true;
      localStorage.setItem('codepsychee_subscription', JSON.stringify(subscription));
      
      console.log('Discord notification prepared:', webhookData);
      
      /* 
       * PRODUCTION IMPLEMENTATION NOTES:
       * For full Discord integration, you'll need:
       * 1. A server-side endpoint to handle Discord webhook POSTs (security)
       * 2. Store Discord webhook URL in environment variables (never in client code)
       * 3. POST webhookData to your server endpoint
       * 4. Server validates and forwards to Discord webhook
       * 
       * Example: fetch('/api/send-discord-notification', { 
       *   method: 'POST', 
       *   body: JSON.stringify(webhookData) 
       * })
       */
      
      // For now, show browser notification as fallback
      if ('Notification' in window && Notification.permission === 'granted') {
        new Notification('üîÆ CodePsychee Alert', {
          body: `Bonus code drop predicted within the hour! Check Instagram soon.`,
          icon: '/favicon.ico'
        });
      }
    }
  </script>
  
  </div>
  
  <!-- Footer -->
  <footer style="margin-top: 4rem; padding: 2rem 0; border-top: 1px solid var(--border); text-align: center;">
    <p style="color: var(--text-secondary); font-size: 0.9rem; margin: 0;">
      <a href="https://jmenichole.github.io/Portfolio/" target="_blank" rel="noopener" style="color: var(--accent); text-decoration: none; transition: color 0.2s ease;">
        made for degens by degens ‚ù§Ô∏è
      </a>
    </p>
  </footer>
  
  <!-- Discord Subscription Modal -->
  <div class="discord-modal" id="discord-modal">
    <div class="discord-modal-content">
      <div class="discord-modal-header">
        <h2>üîÆ Subscribe to CodePsychee</h2>
        <button class="modal-close" id="discord-modal-close">√ó</button>
      </div>
      
      <p style="color: var(--text-secondary); margin-bottom: 1.5rem;">
        Get notified in Discord approximately 1 hour before predicted bonus code drops! 
        CodePsychee uses AI pattern recognition to forecast Instagram bonus drops.
      </p>
      
      <form id="discord-subscribe-form">
        <label style="display: block; margin-bottom: 0.5rem; font-weight: 600; color: var(--text);">
          Discord Username
        </label>
        <input 
          type="text" 
          id="discord-username" 
          class="discord-input" 
          placeholder="username#1234 or @username"
          required
        />
        
        <p style="font-size: 0.875rem; color: var(--text-secondary); margin-top: 0.5rem;">
          üí° Make sure you're in the <a href="https://discord.gg/3hmXPwwa" target="_blank" style="color: var(--accent);">CollectClock Discord server</a> to receive notifications!
        </p>
        
        <button type="submit" class="discord-submit-btn">
          üîÆ Subscribe
        </button>
      </form>
      
      <div style="margin-top: 1.5rem; padding: 1rem; background: var(--accent-light); border-radius: 8px; border-left: 4px solid var(--accent);">
        <p style="margin: 0; font-size: 0.875rem; color: var(--text-secondary);">
          <strong style="color: var(--accent);">‚ú® What is CodePsychee?</strong><br>
          A pun on "Code Psychic" and created by mod Psychee, CodePsychee analyzes 147+ historical bonus drops to predict when the next Instagram bonus code will appear. Subscribe to never miss a drop!
        </p>
      </div>
    </div>
  </div>
  
  <!-- Report Drop Verification Modal -->
  <div class="verification-modal" id="verification-modal">
    <div class="verification-modal-content">
      <div class="discord-modal-header">
        <h2>‚úÖ Report Actual Drop</h2>
        <button class="modal-close" id="verification-modal-close">√ó</button>
      </div>
      
      <p style="color: var(--text-secondary); margin-bottom: 1.5rem;">
        Help improve CodePsychee's accuracy by reporting when actual bonus drops occur. 
        Your feedback trains the AI to make better predictions!
      </p>
      
      <form id="verification-form">
        <div class="form-group">
          <label for="actual-drop-date">Actual Drop Date</label>
          <input 
            type="date" 
            id="actual-drop-date" 
            class="form-input" 
            required
          />
        </div>
        
        <div class="form-group">
          <label for="actual-drop-time">Actual Drop Time (UTC)</label>
          <input 
            type="time" 
            id="actual-drop-time" 
            class="form-input" 
            required
          />
        </div>
        
        <div class="form-group">
          <label for="actual-amount">Actual Bonus Amount ($)</label>
          <select id="actual-amount" class="form-input" required>
            <option value="">Select amount...</option>
            <option value="5">$5</option>
            <option value="10">$10</option>
            <option value="11">$11</option>
            <option value="other">Other/Unknown</option>
          </select>
        </div>
        
        <div class="form-group">
          <label for="notes">Notes (optional)</label>
          <textarea 
            id="notes" 
            class="form-input" 
            rows="3"
            placeholder="Any additional details about the drop..."
          ></textarea>
        </div>
        
        <button type="submit" class="form-submit-btn">
          üìä Submit Verification
        </button>
      </form>
      
      <div style="margin-top: 1.5rem; padding: 1rem; background: var(--success-light); border-radius: 8px; border-left: 4px solid var(--success);">
        <p style="margin: 0; font-size: 0.875rem; color: var(--text-secondary);">
          <strong style="color: var(--success);">üéØ How it works:</strong><br>
          When you report an actual drop, CodePsychee compares it with its prediction to calculate accuracy. 
          The system learns from these verifications to improve future predictions and automatically adds verified drops to the historical database.
        </p>
      </div>
    </div>
  </div>
</body>
</html>
